C++常见面试问题汇总

指针和引用的区别

```
指针和引用在本质上都用于访问同一个对象,但是语法和使用方式上有些差异:

定义语法不同:指针需要使用*来定义,而引用使用&。例如:
int* p; // 定义指针p
int& r = x; // 定义对x的引用r
内存占用不同:指针是一个变量,它存储了目标对象的内存地址。引用不是一个变量,它直接与目标对象绑定。
可重新赋值:指针可以在运行时指向不同的对象,而引用在初始化后不能重新绑定到另一个对象。
可为空:指针可以赋值为NULL,而引用必须绑定到一个对象,不能为空。
传递方式不同:指针传递的是地址,引用传递的是对象本身。
解引用方式不同:*用于解引用指针,而引用可以直接当成对象使用。
总体来说,引用提供了一种更为安全和方便的访问对象的方式,是C++对指针的增强。但指针提供了更大的灵活性,可以重新指向不同对象。选择使用指针还是引用,需要根据具体场景而定。
```

堆和栈的区别

```
存储位置不同:
堆是动态内存分配,位于内存的自由存储区。
栈是自动分配的内存,位于内存的栈区。

分配方式不同:
堆是动态分配,使用 new/malloc 在运行时申请,使用 delete/free 释放。
栈是编译器自动分配和释放。进入一个作用域时分配,退出作用域时释放。

空间大小不同:
堆的大小可以动态调整,没有固定大小限制。
栈的大小在编译时就确定,并且有平台限制。

使用方式不同:
堆分配的内存需要程序员手动管理,容易产生内存泄漏。
栈的内存管理由编译器自动完成,使用简单。

生命周期不同:
堆中的对象生命周期由程序员控制。
栈中的对象生命周期由其作用域控制。

总之,对于需要动态大小和生命周期的对象,应该使用堆;对于大小固定且生命周期由作用域控制的对象,应该使用栈。
```

new和delete是如何实现的，new 与 malloc的异同处

```
new和delete是C++中的运算符,用于对象的动态内存分配和释放,而malloc和free是C语言中的函数,用于一般内存的分配和释放。
new在分配内存的同时还会调用对象的构造函数进行初始化,delete在释放内存前会调用析构函数; malloc/free 仅仅负责内存空间的分配和释放。
new和delete由编译器在背后实现,可能进行额外的内存管理以配合C++的特性,如构造/析构、异常处理等;而 malloc/free 由程序库实现,仅仅完成内存的分配/释放。
new/delete 的内存来自自由存储区(free store), malloc/free 的内存来自堆区(heap),C++中自由存储区是对堆区的封装。
new会在内存不足时抛出异常,malloc会返回空指针;delete接受空指针,free不能。
new/delete 可以被重载, malloc/free 不可以。
总之, new/delete 比 malloc/free 更符合C++的面向对象特性,但后者运行时效率可能更高。选择要根据具体情况决定。
```

Struct和class的区别

```
默认访问权限不同:
struct的成员默认是public的
class的成员默认是private的

继承方式不同:
struct默认是public继承
class默认是private继承

用途不同:
struct更适合构建数据结构,类似C中的struct
class更适合封装功能

效率不同:
struct通常效率略高,因为默认public访问简化了内存布局
class访问控制会影响优化,效率略低

总结:
struct更适合构建相对简单的数据结构;class更适合封装复杂的功能。但这只是一个约定,C++本身并不强制要求这种用法。
```


define 和const的区别（编译阶段、安全性、内存占用等）

```
定义阶段不同:
define是预处理器指令,在预编译阶段展开
const是关键字,在编译阶段处理

作用域不同:
define没有作用域概念,只在定义处替换
const具有作用域,只在作用域内生效

类型不同:
define没有类型,直接替换文本
const可以指定变量类型,有类型检查

内存占用不同:
define不占用内存,只是文本替换
const变量会占用内存

安全性不同:
define比较危险,可能导致意外行为
const较为安全,有类型检查

调试不同:
define不会出现在调试信息中
const出现在调试信息中,便于调试

总结:
const较define更安全,应尽量用const代替define,特别是与类型相关的场景。但define运行效率较高。需根据场景选择。
```

在C++中const和static的用法（定义，用途）

```

const:

定义常量,不可修改的变量。例如:

const int a = 10;
定义常量指针,指向不可修改的对象。例如:

const int* p = &a; // p是指针,指向的值不可修改
定义成员函数,表示不修改成员变量。例如:

class A {
int val;
public:
void set(int v) { val = v; } 
int get() const { return val; } // 不修改val
};
static:

定义静态变量,全局只有一份内存,在程序整个运行期间存在。例如:

static int count = 0; 
定义静态成员变量/函数,不需要通过对象就可以访问。例如:

class A {
public:
static int v;
static void func() {}
};
限制函数或变量只在某文件内可见。例如:

static int x; // x只在当前文件可见
总结:const用于定义常量,防止值被修改;static用于定义静态变量/函数,或限制作用域。

```

const和static在类中使用的注意事项（定义、初始化和使用）

```
对于const和static在类中的使用,需要注意以下几点:

定义时的区别
const成员变量必须在定义时初始化,而非const成员变量可以在构造函数中初始化。

static成员变量可以在类内初始化,也可以在类外初始化。

初始化时的区别
const成员变量只能在定义时初始化一次,后续不可修改。

非const成员变量可以在构造函数中初始化,也可以后续修改。

static成员变量无论在类内还是类外初始化,都仅初始化一次。

使用时的区别
const成员变量在整个类中都为只读,不能修改。

非const成员变量可以通过对象修改。

static成员变量可以通过类名直接访问,不需要创建对象。

命名约定
const成员变量通常使用大写字母命名。

static成员变量通常加前缀s_ 或 k_。

总之,const用于定义常量,static用于静态成员。初始化和使用需要注意其特殊性。
```

C++中的const类成员函数（用法和意义），以及和非const成员函数的区别

```
在C++中,const成员函数的用法和意义以及它与非const成员函数的区别主要如下:

用法
在成员函数声明后加const关键字,表示该函数是const函数,不修改类中的任何成员变量,如:

class A {
  int val;
public:
  void set(int v) { val = v; }
  int get() const { return val; }
};
意义
对类的接口进行限制,明确指定哪些函数可以修改类成员,哪些不能。
可以让const对象调用成员函数,非const对象不一定可以调用const函数。
可以避免const对象被无意间修改。
区别
const函数只能访问类中的const成员变量,非const函数可以访问所有成员变量。
const对象只能调用const函数,非const对象可以调用所有成员函数。
const函数不能修改成员变量,非const函数可以。
注意
const函数如果需要访问非const成员,需要将该成员声明为mutable。

总之,const成员函数用于增加类的接口约束,表示不修改成员变量,提高代码可读性和安全性
```

C++的顶层const和底层const

```
顶层const:
用于对一个变量整体进行const修饰,使其变为只读,不能通过这个变量修改其所指向的内容。例如:

const int* p;

这里p是一个指向int的指针常量,不能通过p来修改它指向的int的值。

底层const:
用于对一个变量所指向的内容进行const修饰,使其不能通过这个变量来修改其所指向的内容,但变量本身是可修改的。例如:

int const * p;

这里p是一个指向const int的指针,可以修改p本身,但不能通过p来修改它所指向的const int的值。

顶层const和底层const可以组合使用:
const int const * p;

这里p既是一个指针常量,也是一个指向const int的指针,既不能修改p本身,也不能通过p修改它所指向的值。

总结:顶层const修饰变量本身,底层const修饰所指向的内容。
```

final和override关键字

```
final:

可以用来修饰类,表示这个类不能被继承,比如:
class Base final {
  //...
};

class Derived : Base { // 错误,Base不能被继承
}; 
可以用来修饰虚函数,表示这个虚函数不能被子类重写,比如:
class Base {
public:
  virtual void foo() final; 
};

class Derived : Base {
  void foo() override; // 错误,foo不能重写
};
override:

用于修饰虚函数,表示这个函数重写了基类的虚函数,如果函数签名与基类中虚函数不一致,编译器会报错。

所以override可以帮助检查是否正确重写了基类虚函数。

总结:

final防止类的继承和函数的重写;override用于标识重写基类虚函数,检查是否正确重写。
```

拷贝初始化和直接初始化，初始化和赋值的区别

```
拷贝初始化:
使用已存在的对象来初始化一个新对象。形式为T x = y; 这里y是已存在的对象。

直接初始化:
直接用括号或花括号给对象赋初值。形式为 T x(args); 或 T x{args};

赋值:
将已存在对象的值赋给另一个已存在的对象。形式为 x = y; 这里x和y都是已存在的对象。

区别:

拷贝初始化和直接初始化都是初始化,发生在对象创建时;赋值是赋值,发生在对象已创建后。

拷贝初始化会调用拷贝构造函数或转换构造函数;直接初始化会调用普通构造函数。

拷贝初始化可以使用=也可以不使用;直接初始化和赋值必须使用括号或花括号。

赋值只能在对象创建后进行,而初始化只能在对象创建时进行。

总结:

初始化发生在对象创建时,只进行一次;赋值可以在对象生命周期的任意时刻进行多次。
```

extern "C" 的用法

```
extern "C"的主要用法是为了兼容C语言,在C++中使用extern "C"可以避免C++名字修饰(name mangling)。

具体来说,extern "C"有以下两个主要作用:

引用C语言代码:
在C++中调用C语言代码时,可以使用extern "C"来防止C++编译器对C语言函数名进行修饰。

例如:

// test.c
void test(); 

// main.cpp
extern "C" {
  void test(); // 引用test.c中的test函数 
}
允许其他语言调用C++代码:
在C++中使用extern "C"可以避免名字修饰,使得其他语言(如C语言)可以方便调用C++代码。

例如:

// test.cpp
extern "C" void test() {
  // ...
}
这样test函数就可以被C语言直接调用,而不需要处理编译器名字修饰的问题。

总之,extern "C"使得C++代码兼容C语言调用,是连接C++与C语言的重要手段。
```

模板函数和模板类的特例化

```
模板特例化的语法如下:

对于模板函数:

// 原模板
template<typename T>
void func(T t) {
  // 通用实现 
}

// 特例化 
template<>  
void func<int>(int t) {
  // int的特例化实现
}
对于模板类:

// 原模板
template<typename T>
class MyClass {
  // 通用实现
}; 

// 特例化
template<>
class MyClass<double> {
  // double的特例化实现 
};
特例化允许我们针对某些类型提供自定义的实现,提高代码复用性。

常见的特例化场景包括:

为某些类型提供更优化的实现
为某些类型添加额外的功能或属性
为某些类型使用完全不同的实现逻辑
需要注意,特例化只能针对整个类型进行,不能对类型的一部分进行特例化。
```

C++的STL源码其中包括内存池机制，各种容器的底层实现机制，算法的实现原理等）

```
内存池机制
STL会预先分配一块内存作为内存池,各种容器从这个池中申请和释放内存,避免频繁调用 new/delete 带来的性能损失。

各种容器的实现
vector使用连续内存空间,可快速随机访问,但插入删除效率低。

list使用双向链表,插入删除快,但随机访问慢。

deque使用分段连续空间,兼具vector和list的优点。

set/map使用红黑树实现,可以自动维护有序。

unordered_set/unordered_map使用哈希表实现。

算法的实现
sort使用快速排序、归并排序或插入排序。

find、count等算法使用线性搜索。

lower_bound、upper_bound等使用二分查找。

STL源码中应用了大量算法设计与分析的知识,通过空间换时间的思想,实现高效的容器和算法。这为我们提供了很好的学习模板。
```

STL源码中的hashtable的实现

```

STL源码中的哈希表(hashtable)主要有以下几点实现:

使用开放寻址法解决冲突,探查序列包括线性探查、二次探查、双重散列等。

动态扩容,当桶数使用比例超过阈值(通常75%)时,会重新分配更大的桶数组,并重新散列。

桶数一般设置为素数或次素数,可以减少冲突。

负载因子控制桶数和容量的动态平衡。

使用红黑树优化性能,当桶内元素过多时,会转为红黑树结构,提高查找速度。

采用链式散列解决冲突,每个桶是一个链表。

使用空桶和删除标记优化空间利用率。

实现哈希函数和相等比较函数,支持自定义键类型。

使用分配器(allocator)管理内存分配。

优化缓存行利用,增强局部性。

总体来说,STL的hashtable通过空间换时间实现高效插入和查询,是实现关联容器的核心组件。
```

STL中unordered_map和map的区别和应用场景

STL中vector的实现

```
STL中的vector主要通过以下几点实现:

使用连续的动态数组作为底层存储,可以快速随机访问。

空间预分配和扩容机制 - 当数组容量不足时,按一定策略(通常是2倍)扩容,以减少重新分配的次数。

存储在堆上,使用智能指针管理数组内存,实现RAII。

封装动态数组,提供迭代器、容量信息、插入删除等接口。

移动语义 - 支持移动构造和移动赋值,避免不必要的拷贝。

空间优化 - 使用空间压缩和小对象优化,减少内存占用。

缓存友好 - 数据结构对缓存访问友好,增强局部性。

算法和容器分离 - 算法由迭代器定义,可应用于不同容器。

异常安全 - 异常不会破坏vector的结构。

综上,vector通过空间换时间提供快速随机访问,是最常用的STL序列容器。
```

STL容器的几种迭代器以及对应的容器（输入迭代器，输出迭代器，前向迭代器，双向迭代器，随机访问迭代器）

```
您好,STL容器主要有以下几种迭代器及对应的容器:

输入迭代器(input iterator):只能单向进行读取操作的迭代器,如istream_iterator。

输出迭代器(output iterator):只能单向进行写入操作的迭代器,如ostream_iterator。

前向迭代器(forward iterator):支持读操作,并能向后单步移动的迭代器,如unordered_set的迭代器。

双向迭代器(bidirectional iterator):支持读写操作,并能双向移动的迭代器,如list、set、map的迭代器。

随机访问迭代器(random access iterator):支持读写操作,并能随机访问任意位置的迭代器,如vector、deque的迭代器。

主要容器对应的迭代器类型:

vector,deque:随机访问迭代器
list:双向迭代器
set,map,multiset,multimap:双向迭代器
unordered_set,unordered_map:前向迭代器

容器适配器stack,queue,priority_queue没有对应的迭代器。

迭代器的类型决定了容器支持的算法和功能,选择容器时需要根据访问方式选择匹配的迭代器类型。

顺序容器：vector, deque是随机访问迭代器, list是双向迭代器

容器适配器：stack,queue,priority_queue没有迭代器

关联容器：set,map,multiset,multimap是双向迭代器

unordered_set,unordered_map,unordered_multiset,unordered_multimap是前向迭代器
```


STL中的traits技法
type_traits

iterator_traits

char traits

allocator_traits

pointer_traits

array_traits

```

STL中使用了traits技术来实现泛型编程,主要的traits类有:

type_traits: 提供了查询和修改类型属性的模板类,如is_integral、is_pointer等来判断类型的特征。

iterator_traits: 提取迭代器的特征,提供统一的接口访问迭代器的属性,如迭代器的类别、值类型等。

char_traits: 定义字符类型的相关属性,用于给基于字符的容器提供类型信息。

allocator_traits: 定义标准容器的分配器的统一接口。

pointer_traits: 定义指针的统一访问接口。

array_traits: 提供访问数组属性的接口。

traits技术通过模板和泛型编程实现代码复用,将类型的属性和功能分离,提高了扩展性和复用性。这些traits为STL提供了跨平台和可扩展的实现基础。

总体来说,traits在STL中发挥了参数化和重用的作用,是STL设计的重要组成部分。
```


vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。

```
频繁调用push_back会触发vector扩容,影响性能。
vector在元素数量达到容量上限时会触发扩容,每次典型扩容为当前容量的2倍,这会重新分配内存和复制元素,影响效率。

如果知道元素数量,可以通过reserve()预先分配容量,减少扩容次数。

避免在vector中间插入删除元素。
vector使用连续存储,中间插入删除效率低,需要移动大量元素。应该仅在末尾进行 push/pop 操作。

如果需要频繁随机访问,vector效率很高。
vector使用连续存储,支持通过下标快速随机访问任意元素。

传入vector的对象类型应该轻量,避免大对象拷贝。
vector在扩容时需要拷贝所有元素,如果元素较大会带来不必要开销。

可以通过数据结构组合得到需要的性能,例如vector+list。
综上,使用vector时根据场景选择合适的使用方式很重要,才能发挥其性能优势。
```

C++中的重载和重写的区别

C++内存管理，内存池技术（热门问题），与csapp中几种内存分配方式对比学习加深理解

介绍面向对象的三大特性，并且举例说明每一个

C++多态的实现

C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（包括单一继承，多重继承等）（拓展问题：为什么基类指针指向派生类对象时可以调用派生类成员函数，基类的虚函数存放在内存的什么区，虚函数表指针vptr的初始化时间）

```
虚函数表(Virtual Table)
每个类中都有一个虚函数表,存放类中所有虚函数的函数指针。虚函数表是个静态数组,由编译器生成。

虚函数指针(vptr)
每个类实例中都有一个虚函数指针,指向该类的虚函数表,用于动态找到正确的虚函数。

单继承
对于单继承,派生类的虚函数表中包含自己的虚函数和从基类继承的虚函数。基类指针可以调用派生类虚函数,是通过虚函数表指针找到派生类的虚函数实现。

多继承
多继承时,每个派生类有多个虚函数表指针,指向不同基类的虚函数表,用于区分不同基类的虚函数。

虚函数表位于程序只读数据区,不允许修改。

虚函数表指针vptr是类的数据成员,在构造函数中初始化。

基类的虚函数存放在内存的只读数据区(read-only data)。

C++中的虚函数表(Virtual Table)以及虚函数指针(vptr)都是存放在程序的只读数据区的,不允许修改。

只读数据区主要包括程序代码段和常量数据,通常是可共享的内存区域。把虚函数表放在这里可以让程序中的多个实例对象共享使用同一份虚函数表,而不需要每一个实例都复制一份虚函数表。

另外,只读数据区由操作系统管理,有较高的访问效率。放在这里可以加速虚函数的访问。

所以为了节省内存空间,以及加速访问速度,C++的虚函数和虚函数表都是放在程序只读数据区的。


```


C++中类的数据成员和成员函数内存分布情况

```
在C++中,类的数据成员和成员函数的内存分布情况如下:

数据成员:
非静态数据成员存放在每个类实例的内存空间中。
静态数据成员存放在全局静态存储区,所有实例共享一份。
成员函数:
非虚成员函数直接存放在代码段中。
虚函数的函数体存放在代码段中,虚函数表存放在只读数据段中。
对于每个类实例:
在栈上分配实例本身所需的内存。
在堆上通过new分配的数据成员内存。
包含一个this指针,指向实例本身。
包含一个虚函数表指针 vptr,如果有虚函数的话。
所以简单来说,数据成员和this指针在实例内存中,代码在代码段中,虚函数表在只读数据段中。成员的布局由编译器控制。
```

this指针
析构函数一般写成虚函数的原因

```
析构函数之所以通常声明为虚函数,主要有以下原因:

允许正确调用派生类的析构函数
如果基类析构函数是非虚函数,那么通过基类指针删除派生类对象时,只会调用基类析构函数,而不会调用派生类的析构函数,可能导致资源泄露。

实现运行时多态
虚析构函数可以与虚函数配合实现运行时多态,正确析构对象。

维护类的继承体系
如果基类析构函数不是虚函数,那么继承体系中所有的析构函数都需要是虚函数,否则删除基类指针时可能导致未定义行为。

符合用户的预期
用户通常会认为使用基类指针删除对象会调用相应的析构函数,这与虚析构函数的语义一致。

提高复用性
如果基类析构函数是虚函数,那么用户不需要关心具体调用哪个类的析构函数,可以复用基类指针安全删除对象。

所以虚析构函数可以增强程序的健壮性,使得类继承体系中的析构行为更加可预测,也更符合用户的直觉。这是虚析构函数的重要意义。
```

构造函数、拷贝构造函数和赋值操作符的区别
构造函数：对象不存在，没用别的对象初始化

拷贝构造函数：对象不存在，用别的对象初始化

赋值运算符：对象存在，用别的对象给它赋值

构造函数声明为explicit
构造函数为什么一般不定义为虚函数
构造函数的几种关键字(default delete 0)
= default：将拷贝控制成员定义为=default显式要求编译器生成合成的版本

= delete：将拷贝构造函数和拷贝赋值运算符定义删除的函数，阻止拷贝（析构函数不能是删除的函数 C++Primer P450）

= 0：将虚函数定义为纯虚函数（纯虚函数无需定义，= 0只能出现在类内部虚函数的声明语句处；当然，也可以为纯虚函数提供定义，不过函数体必须定义在类的外部）

构造函数或者析构函数中调用虚函数会怎样
纯虚函数
静态类型和动态类型，静态绑定和动态绑定的介绍
引用是否能实现动态绑定，为什么引用可以实现
深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）
对象复用的了解，零拷贝的了解
介绍C++所有的构造函数
什么情况下会调用拷贝构造函数（三种情况）
结构体内存对齐方式和为什么要进行内存对齐？
内存泄露的定义，如何检测与避免？
手写智能指针的实现（shared_ptr和weak_ptr实现的区别）
智能指针的循环引用
遇到coredump要怎么调试
内存检查工具的了解
模板的用法与适用场景
成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？
用过C++ 11吗，知道C++ 11哪些新特性？
C++的调用惯例（简单一点C++函数调用的压栈过程）
C++的四种强制转换
static_cast

dynamic_cast

const_cast

reinterpret_cast

C++中将临时变量作为返回值的时候的处理过程（栈上的内存分配、拷贝过程）
C++的异常处理
volatile关键字
优化程序的几种方法
public，protected和private访问权限和继承
class和struct的区别
decltype()和auto
inline和宏定义的区别
C++和C的类型安全